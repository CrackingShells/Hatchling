name: Reusable PR branch & author validator

on:
  workflow_call:
    inputs:
        allowed_prefixes:
            required: true
            type: string
        allowed_exact:
            required: false
            type: string
            default: ''
        require_org_for:
            required: false
            type: string
            default: ''
        allowed_apps:
            required: false
            type: string
            default: ''
        org_name:
            required: false
            type: string
            default: 'CrackingShells'
        fail_message:
            required: false
            type: string
            default: ''

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      branch_valid: ${{ steps.check.outputs.branch_valid }}
    steps:
      - name: Generate GitHub App token
        id: generate-token
        uses: tibdex/github-app-token@v2
        with:
          app_id: ${{ secrets.HATCH_WORKFLOW_APP_ID }}
          private_key: ${{ secrets.HATCH_WORKFLOW_APP_PRIVATE_KEY }}

      - name: Run branch and author checks
        id: check
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.generate-token.outputs.token }}
          script: |
            const branch = process.env.GITHUB_HEAD_REF || '${{ github.head_ref }}';
            const author = '${{ github.event.pull_request.user.login }}';
            const prNumber = ${{ github.event.pull_request.number }};
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const allowedPrefixes = (`${{ inputs.allowed_prefixes }}` || '').split(',').map(s => s.trim()).filter(Boolean);
            const allowedExact = (`${{ inputs.allowed_exact }}` || '').split(',').map(s => s.trim()).filter(Boolean);
            const requireOrgFor = (`${{ inputs.require_org_for }}` || '').split(',').map(s => s.trim()).filter(Boolean);
            const allowedApps = (`${{ inputs.allowed_apps }}` || '').split(',').map(s => s.trim()).filter(Boolean);
            const failMessage = `${{ inputs.fail_message }}` || 'Branch not allowed to open PR to this target.';

            function matchesAllowed() {
              for (const p of allowedPrefixes) {
                if (p.endsWith('/')) {
                  if (branch.startsWith(p)) return true;
                } else {
                  if (branch === p) return true;
                }
              }
              if (allowedExact.includes(branch)) return true;
              return false;
            }

            async function isOrgMember() {
              const orgName = `${{ inputs.org_name }}` || 'CrackingShells';
              try {
                const res = await github.rest.orgs.checkMembershipForUser({ org: orgName, username: author });
                return res.status === 204;
              } catch (e) {
                return false;
              }
            }

            // Allowed by prefix/exact test first
            if (!matchesAllowed()) {
              const message = `${failMessage}\nYour branch: ${branch}.`;
              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner,
                repo,
                body: message
              });
              core.setFailed('Invalid branch for PR.');
              core.setOutput('branch_valid', 'invalid');
              return;
            }

            // If author is an allowed app, allow
            if (allowedApps.includes(author)) {
              console.log(`Author ${author} is in allowed apps list`);
              core.setOutput('branch_valid', 'valid');
              return;
            }

            // If this branch requires org membership, check
            if (requireOrgFor.includes(branch) || requireOrgFor.some(b => b === branch)) {
              if (!await isOrgMember()) {
                const message = `⚠️ Only members of the ${`${{ inputs.org_name }}`} organization can open PRs from '${branch}' to this target.`;
                await github.rest.issues.createComment({
                  issue_number: prNumber,
                  owner,
                  repo,
                  body: message
                });
                core.setFailed('PR author is not a member of the organization.');
                core.setOutput('branch_valid', 'invalid');
                return;
              }
              core.setOutput('branch_valid', 'valid');
              return;
            }

            // Special case: version-bump behavior - allow if org member OR allowed app
            if (branch === 'version-bump') {
              if (await isOrgMember()) { core.setOutput('branch_valid', 'valid'); return; }
              const isAllowedApp = allowedApps.includes(author);
              if (isAllowedApp) { core.setOutput('branch_valid', 'valid'); return; }
              const message = `❌ Only organization members or registered GitHub Apps (${allowedApps.join(', ')}) can open PRs from 'version-bump' to this target.\nYour author: ${author}`;
              await github.rest.issues.createComment({
                issue_number: prNumber,
                owner,
                repo,
                body: message
              });
              core.setFailed('PR author is not allowed for version-bump branch.');
              core.setOutput('branch_valid', 'invalid');
              return;
            }

            // Otherwise allowed
            core.setOutput('branch_valid', 'valid');
            return;
